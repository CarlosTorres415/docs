"use strict";(self.webpackChunkflashbot_docs=self.webpackChunkflashbot_docs||[]).push([[1457],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,g=u["".concat(c,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(g,s(s({ref:t},p),{},{components:n})):a.createElement(g,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5675:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],o={title:"signing transactions"},c=void 0,l={unversionedId:"flashbots-protect/api/signing-transactions",id:"flashbots-protect/api/signing-transactions",isDocsHomePage:!1,title:"signing transactions",description:"To use the Flashbots Protect API you must submit signed transactions. The Protect API then submits those transactions as bundles to Flashbots for inclusion on-chain. If you are building a user facing application the flow for generating signed transactions is different from how you usually prompt users to execute transations. In particular, we use ethsign or ethsignTransaction, depending on the wallet (more on that below) to build signed transactions that are then submitted in a BundleReq object to the Flashbots Protect API websocket.",source:"@site/docs/flashbots-protect/api/signing-transactions.md",sourceDirName:"flashbots-protect/api",slug:"/flashbots-protect/api/signing-transactions",permalink:"/flashbots-protect/api/signing-transactions",tags:[],version:"current",frontMatter:{title:"signing transactions"},sidebar:"docs",previous:{title:"websockets",permalink:"/flashbots-protect/api/websockets"},next:{title:"uncle bandit risk",permalink:"/flashbots-protect/api/uncle-bandits"}},p=[{value:"Signing Methods",id:"signing-methods",children:[{value:"eth_sign",id:"eth_sign",children:[]},{value:"eth_signTransaction",id:"eth_signtransaction",children:[]}]},{value:"Examples",id:"examples",children:[{value:"Prepare a Signed Transaction &amp; Submit Bundle with mistx-connect, a community library that makes it easier to interact with the Flashbots Protect API",id:"prepare-a-signed-transaction--submit-bundle-with-mistx-connect-a-community-library-that-makes-it-easier-to-interact-with-the-flashbots-protect-api",children:[]}]},{value:"Signed Approvals",id:"signed-approvals",children:[]}],d={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"To use the Flashbots Protect API you must submit signed transactions. The Protect API then submits those transactions as bundles to Flashbots for inclusion on-chain. If you are building a user facing application the flow for generating signed transactions is different from how you usually prompt users to execute transations. In particular, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"eth_sign")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"eth_signTransaction"),", depending on the wallet (more on that below) to build signed transactions that are then submitted in a ",(0,i.kt)("inlineCode",{parentName:"p"},"BundleReq")," object to the Flashbots Protect API websocket."),(0,i.kt)("p",null,"As a part of this guide we assume you know what digital signatures are and why they are a key part of blockchains. To learn more about digital signatures, check out this article by MyCrypto, ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7"},"The Magic of Digital Signatures on Ethereum"),"."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"All examples use ethers.js and/or web3-react"))),(0,i.kt)("h2",{id:"signing-methods"},"Signing Methods"),(0,i.kt)("h3",{id:"eth_sign"},"eth_sign"),(0,i.kt)("p",null,"eth_sign is an arbitrary signing method and can be used when signing transactions for metamask. After a signature is returned from eth_sign, the signed transaction can be created with the user's signature and populate transaction object."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Parameters:"))),(0,i.kt)("p",null,"address - The address to be signed with."),(0,i.kt)("p",null,"message - hashed serialized transaction"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Returns:"))),(0,i.kt)("p",null,"result - The signature"),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const signature = await library.jsonRpcFetchFunc('eth_sign', [account, hash])\nconst signedTx = ethers.utils.serializeTransaction(populatedTx, signature)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Supported Wallets:"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"MetaMask")),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If you are using web3-react you must set ",(0,i.kt)("inlineCode",{parentName:"p"},"library.provider.isMetamask = false")," before signing."))),(0,i.kt)("h3",{id:"eth_signtransaction"},"eth_signTransaction"),(0,i.kt)("p",null,"eth_signTransaction signs a transaction that can be submitted to the network later. If the user is connected with Metamask, eth_sign must be used as Metamask does not currently support eth_signTransaction."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Parameters:"))),(0,i.kt)("p",null,"object - The transaction object."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"from - The address the transaction is sent from.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"to - The address the transaction is directed to.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"gas - HexString of the gas provided for the transaction execution.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"gasLimit - HexString of the gas provided for the transaction execution.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"gasPrice - HexString of the gasPrice used for each paid gas, in Wei.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"value - HexStirng of the value sent with this transaction, in Wei.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"data - the hash of the invoked method signature and encoded parameters.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"nonce - Integer of a nonce."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Returns:"))),(0,i.kt)("p",null,"result - The signed transaction object."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const signedTxRes: SignedTransactionResponse = await library.jsonRpcFetchFunc(\n  'eth_signTransaction',\n  [\n    {\n      from,\n      to,\n      gas, // same as gasLimit\n      gasLimit, // same as gas\n      maxFeePerGas, // max base fee per gas,\n      maxPriorityFeePerGas: '0x0',\n      nonce,\n      value, // can be '0x0'\n    }\n  ]\n)\n\nconst signedTx = signedTxRes.raw\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Supported Wallets:"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ledger")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("h3",{id:"prepare-a-signed-transaction--submit-bundle-with-mistx-connect-a-community-library-that-makes-it-easier-to-interact-with-the-flashbots-protect-api"},"Prepare a Signed Transaction & Submit Bundle with mistx-connect, a community library that makes it easier to interact with the Flashbots Protect API"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Contract } from '@ethersproject/contracts'\nimport { Router } from '@alchemist-coin/mistx-core';\nimport { TransactionReq, SwapReq, emitTransactionRequest, BundleReq } from '@alchemist-coin/mistx-connect'\nimport { formatUnits } from 'ethers/lib/utils'\nimport { abi as MISTX_ROUTER_ABI } from './mistx-router-abi.json'\n\nconst { account, chainId, library } = useActiveWeb3React()\nconst MISTX_DEFAULT_GAS_LIMIT = 375000 // enough gas to cover most (>90%) swaps\nconst CURRENT_BASE_FEE =\nconst mistXRouterAddress = '0xA58f22e0766B3764376c92915BA545d583c19DBc' // Uni v2 - Mainnet\nconst contract = new Contract(\n  address,\n  MISTX_ROUTER_ABI,\n  account ? getSigner(library, account) : library\n)\n\nconst { methodName, args, value } = Router.swapCallParameters(trade, {\n  feeOnTransfer: false,\n  allowedSlippage: new Percent(JSBI.BigInt(100), BIPS_BASE), // 1%\n  recipient: account, // account or recipient address\n  ttl: 5 * 60, // 5 minutes (seconds)\n})\nconst maxBaseFeePerGas = BigNumber.from(CURRENT_BASE_FEE * (1.125**4)) //\n\nif (!(contract.signer instanceof JsonRpcSigner)) {\n  throw new Error(`Cannot sign transactions with this wallet type`)\n}\n\nlet web3Provider: Web3Provider | undefined\nlet isMetamask: boolean | undefined\n\ntry {\n  const signedApproval = await approve() // only required for token->token and token->eth\n\n  // ethers will change eth_sign to personal_sign if it detects metamask\n  if (library instanceof Web3Provider) {\n    web3Provider = library as Web3Provider\n    isMetamask = web3Provider.provider.isMetaMask\n    web3Provider.provider.isMetaMask = false\n  }\n\n  try {\n    const nonce =\n      signedApproval === undefined\n        ? await contract.signer.getTransactionCount()\n        : await contract.signer.getTransactionCount().then(nonce => {\n            return nonce + 1\n          })\n    const populatedTx: PopulatedTransaction = await contract.populateTransaction[methodName](...args, {\n      //modify nonce if we also have an approval\n      nonce: nonce,\n      gasLimit: BigNumber.from(MISTX_DEFAULT_GAS_LIMIT),\n      type: 2, // eip-1559\n      maxFeePerGas: maxBaseFeePerGas, // max base fee in wei. recommend current base fee * (1.25^4)\n      maxPriorityFeePerGas: '0x0',\n      ...(value && !isZero(value) ? { value } : { value: '0x0' })\n    })\n\n    // delete for serialize necessary\n    populatedTx.chainId = chainId\n    // HANDLE METAMASK\n    // MetaMask does not support eth_signTransaction so we must use eth_sign as a workaround.\n    // For other wallets, use eth_signTransaction\n    let signedTx\n    if (isMetamask) {\n      delete populatedTx.from\n      const serialized = ethers.utils.serializeTransaction(populatedTx)\n      const hash = keccak256(serialized)\n      const signature: SignatureLike = await library.jsonRpcFetchFunc('eth_sign', [account, hash])\n      // this returns the transaction & signature serialized and ready to broadcast\n      signedTx = ethers.utils.serializeTransaction(populatedTx, signature)\n    } else {\n      const payload = [\n        {\n          ...populatedTx,\n          chainId: undefined,\n          gas: `0x${populatedTx.gasLimit?.toNumber().toString(16)}`,\n          gasLimit: `0x${populatedTx.gasLimit?.toNumber().toString(16)}`,\n          maxFeePerGas: `0x${populatedTx.maxFeePerGas?.toNumber().toString(18)}`,\n          maxPriorityFeePerGas: '0x0',\n          nonce: `0x${populatedTx.nonce?.toString(16)}`,\n          ...(value && !isZero(value) ? { value } : { value: '0x0' })\n        }\n      ]\n      const signedTxRes: SignedTransactionResponse = await library.jsonRpcFetchFunc(\n        'eth_signTransaction',\n        payload\n      )\n      signedTx = signedTxRes.raw\n    }\n\n    // Set isMetaMask again after signing. (workaround for an issue with isMetaMask set on the provider during signing)\n    if (web3Provider) {\n      web3Provider.provider.isMetaMask = isMetamask\n    }\n\n    const minerBribeBN = BigNumber.from(args[1])\n    const totalFees = minerBribeBN\n    const estimatedEffectiveGasPriceBn = totalFees.div(BigNumber.from(YOUR_TRADE_ESTIMATED_GAS_PRICE))\n    const estimatedEffectiveGasPrice = Number(formatUnits(estimatedEffectiveGasPriceBn, 'gwei'))\n    const swapReq: SwapReq = {\n      amount0: args[0][0] as string,\n      amount1: args[0][1] as string,\n      path: args[0][2] as string[],\n      to: args[0][3] as string\n    }\n\n    // Create the transaction body with the serialized tx\n    const transactionReq: TransactionReq = {\n      estimatedGas: Number(trade.estimatedGas),\n      estimatedEffectiveGasPrice,\n      serialized: signedTx,\n      raw: swapReq\n    }\n\n    // Create the transactions array with the serialized tx object\n    const transactions: TransactionReq[] = [transactionReq]\n\n    // Check if there is a signed approval with this tx\n    // (token -> eth & token -> token transactions require signed approval)\n    if (signedApproval) {\n      // if there is an approval, create the Approval tx object\n      const signedTransactionApproval: TransactionReq = {\n        estimatedGas: 25000,\n        estimatedEffectiveGasPrice: 0,\n        serialized: signedApproval,\n        raw: undefined\n      }\n      // Add the approval to the transactions array\n      transactions.unshift(signedTransactionApproval) // signed approval first\n    }\n\n    // Create the bundle request object\n    const bundleReq: BundleReq = {\n      transactions,\n      chainId,\n      bribe: args[1],\n      from: account,\n      deadline: BigNumber.from(Math.floor(Date.now() / 1000))\n        .add(deadline)\n        .toHexString(),\n      simulateOnly: false\n    }\n\n    // emit transaction request socket event\n    emitBundleRequest(bundleReq)\n  } catch (error) {\n    // if the user rejected the tx, pass this along\n    if (error?.code === 4001) {\n      throw new Error('Transaction rejected.')\n    } else {\n      // otherwise, the error was unexpected and we need to convey that\n      throw new Error(`Swap failed: ${error.message}`)\n    }\n  }\n} catch (error) {\n  // Set isMetaMask again after signing. (workaround for an issue with isMetaMask set on the provider during signing)\n  if (web3Provider && isMetamask) {\n    web3Provider.provider.isMetaMask = isMetamask\n  }\n  throw new Error(`Approval Failed: ${error.message}`)\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"signed-approvals"},"Signed Approvals"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Token -> Token")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Token -> ETH")," swaps require an additional signed approval by the user. When creating the bundle in this case, two transactions are sent, with the signed approval first."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// BundleReq\n{\n  transactions: [approvalTxReq, txReq], // [txReq] for ETH -> Token transactions\n  ...\n}\n")))}u.isMDXComponent=!0}}]);