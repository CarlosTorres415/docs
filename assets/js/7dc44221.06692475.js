"use strict";(self.webpackChunkflashbot_docs=self.webpackChunkflashbot_docs||[]).push([[5724],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=r,m=h["".concat(c,".").concat(u)]||h[u]||d[u]||i;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5510:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return h}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={title:"codebase - deep dive"},c=void 0,l={unversionedId:"flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",id:"flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",isDocsHomePage:!1,title:"codebase - deep dive",description:"A deep dive into the codebase, particularly for those who are looking to get familiar with both Rust and the inspect codebase",source:"@site/docs/flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive.mdx",sourceDirName:"flashbots-data/deprecated/mev-inspect-rs",slug:"/flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",permalink:"/flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",tags:[],version:"current",frontMatter:{title:"codebase - deep dive"}},p=[{value:"<code>main.rs</code>",id:"mainrs",children:[{value:"<code>main()</code>",id:"main",children:[]},{value:"<code>run()</code>",id:"run",children:[]},{value:"Inspecting a tx",id:"inspecting-a-tx",children:[]},{value:"Inspecting a block",id:"inspecting-a-block",children:[]},{value:"<code>src/prices.rs</code>",id:"srcpricesrs",children:[]},{value:"Sample inspector - <code>src/inspectors/aave.rs</code>",id:"sample-inspector---srcinspectorsaavers",children:[]},{value:"Deriving from Traits",id:"deriving-from-traits",children:[]}]}],d={toc:p};function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A deep dive into the codebase, particularly for those who are looking to get familiar with both Rust and the inspect codebase"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Notes courtesy of Will Drevo, ",(0,i.kt)("a",{parentName:"em",href:"https://github.com/worldveil/mev-inspect-rs/blob/master/NOTES.md"},"source"))),(0,i.kt)("h2",{id:"mainrs"},(0,i.kt)("inlineCode",{parentName:"h2"},"main.rs")),(0,i.kt)("h3",{id:"main"},(0,i.kt)("inlineCode",{parentName:"h3"},"main()")),(0,i.kt)("p",null,"This is where the execution begins, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"main()")," function. Note it is an async function, which returns a Future. ",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"},"Read more here"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/gumdrop/0.5.0/gumdrop/trait.Options.html"},"gumdrop::Options")," package (crate) is used for command line option parsing. The order of arguments here matters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'# will work\n./target/release/mev-inspect -u http://localhost:8080 tx 0xa72072f5041bcde89c560ba12cc00b22a87779ee369dbff81a78bba26d35e989\n\n# won\'t parse url\n./target/release/mev-inspect tx 0xa72072f5041bcde89c560ba12cc00b22a87779ee369dbff81a78bba26d35e989 -u http://localhost:8080\n# will return "unrecognized option `-u`"\n')),(0,i.kt)("p",null,"We parse the arguments with ",(0,i.kt)("inlineCode",{parentName:"p"},"Opts::parse_args_default_or_exit()"),". Next we want to retrieve a tx from a provider (ETH node), but we want to check if it's in the cache."),(0,i.kt)("p",null,"We use this line ",(0,i.kt)("inlineCode",{parentName:"p"},"let Some(ref cache) = opts.cache")," to test for this. ",(0,i.kt)("inlineCode",{parentName:"p"},"opts.cache")," is an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<PathBuf>"),", meaning it either has no value (null), or is a ",(0,i.kt)("inlineCode",{parentName:"p"},"PathBuf"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(&Option<PathBuf>)")," returns true if the reference is non-null. Additionally, these two are the same:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// using ref operator\nlet Some(ref cache) = opts.cache\n// is identical to\nlet Some(cache) = &opts.cache\n")),(0,i.kt)("p",null,"Then we create a provider, either the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/ethers-providers/0.2.2/ethers_providers/struct.Provider.html"},"ethers::providers::Provider"),", or the cached version, which reads from disk."),(0,i.kt)("h3",{id:"run"},(0,i.kt)("inlineCode",{parentName:"h3"},"run()")),(0,i.kt)("p",null,"This is a complex function definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"async fn run<M: Middleware + Clone + 'static>(provider: M, opts: Opts) -> anyhow::Result<()> { ... }\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"takes the provider & options as input"),(0,i.kt)("li",{parentName:"ul"},"returns an ",(0,i.kt)("a",{parentName:"li",href:"https://docs.rs/anyhow/1.0.0/anyhow/type.Result.html"},"anyhow:::Result"),", which is some nice syntactic sugar around catching and printing context and a backtrace if something goes wrong. See ",(0,i.kt)("a",{parentName:"li",href:"https://docs.rs/anyhow/1.0.0/anyhow/trait.Context.html"},"here")," specifically for how to add context inside a function."),(0,i.kt)("li",{parentName:"ul"},"defines a type ",(0,i.kt)("inlineCode",{parentName:"li"},"M")," that accepts any type that implements the Middleware, Clone, and ",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html#trait-bound"},"static lifetime")," traits. This is like an interface in Java. In our code, you can see how this was done for ",(0,i.kt)("inlineCode",{parentName:"li"},"CachedProvider")," (src/cached_provider.rs).")),(0,i.kt)("p",null,"We wrap our provider in a reference counter ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/sync/struct.Arc.html"},"std::styc::Arc"),", which is the ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/49834496"},"C++ equvilent of std::shared_ptr"),", inorder to prevent memory leaks."),(0,i.kt)("p",null,"We create a ",(0,i.kt)("inlineCode",{parentName:"p"},"mev_inspect::HistoricalPrice")," object, giving it a provider, the price coming from Uniswap."),(0,i.kt)("p",null,"The inspectors are added to a vector. They are encased in ",(0,i.kt)("inlineCode",{parentName:"p"},"std::Box"),"es, which tells Rust to put these objects on the heap. This might seem silly at first (...after all, elements in a variable sized data structure like ",(0,i.kt)("inlineCode",{parentName:"p"},"Vec")," (vector) ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/43642518"},"are stored in the heap"),"), but since we are using generics to hold a list of objects of a different type but all implement the same interface (ie: ",(0,i.kt)("inlineCode",{parentName:"p"},"Vec<Box<dyn Inspector>>"),"), the Box has the additional benefit of preventing the compiler from complaining about not knowing how much memory to set aside a prioi. If you remove the std::Box encasement, you'll get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"the size for values of type `dyn mev_inspect::Inspector` cannot be known at compilation time\n\ndoesn't have a size known at compile-time\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/keyword.dyn.html"},(0,i.kt)("inlineCode",{parentName:"a"},"dyn")," keyword")," isn't strictly necessary (the compiler will make this trait dynamically dispatched), but know that it's depcrated and you'll get a warning."),(0,i.kt)("p",null,"Next we create a vector of reducers."),(0,i.kt)("p",null,"After that, we create a processor."),(0,i.kt)("p",null,"The connection between these different types seems to be:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inspectors"),' are "parsers" that know how a given contract is set up, and are able to extract necessary fields'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Reducers"),' are "checkers" that examine extracted fields for different MEV actions'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Processor")," is a coordinating object that takes inspectors and parsers to inspect transactions")),(0,i.kt)("p",null,"Next we create a database connection."),(0,i.kt)("p",null,"Next we match on command, but if it's a tx, we inspect."),(0,i.kt)("h3",{id:"inspecting-a-tx"},"Inspecting a tx"),(0,i.kt)("p",null,"We create a ",(0,i.kt)("inlineCode",{parentName:"p"},"mev_inspect::types::Inspection"),". This seems to choose the correct inspector and from that extracts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"status (success/fail)"),(0,i.kt)("li",{parentName:"ul"},"actions that happened, which can be any of the ones described ",(0,i.kt)("a",{parentName:"li",href:"inspect-codebase-design"},"here")),(0,i.kt)("li",{parentName:"ul"},"protocols involved"),(0,i.kt)("li",{parentName:"ul"},"the sender, contract (if any), and proxy contract (if any) of the tx"),(0,i.kt)("li",{parentName:"ul"},"tx hsh & block height")),(0,i.kt)("p",null,"We query the provider for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the gas_used (from receipt)"),(0,i.kt)("li",{parentName:"ul"},"the gas_price (from tx)")),(0,i.kt)("p",null,"With the inspection, gas_price, gas_used, and pricing in hand, we can coalesce into a ",(0,i.kt)("inlineCode",{parentName:"p"},"mev_inspect::types::Evaluation")," struct which holds:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"mev_inspect::types::Inspection")," object"),(0,i.kt)("li",{parentName:"ul"},"gas_used, gas_price"),(0,i.kt)("li",{parentName:"ul"},"actions involved"),(0,i.kt)("li",{parentName:"ul"},"profit made!")),(0,i.kt)("p",null,"Finally, we insert the evaluation into the database."),(0,i.kt)("h3",{id:"inspecting-a-block"},"Inspecting a block"),(0,i.kt)("p",null,"If the command is instead for a range of blocks, we iterate through this range one by one and process the block given the usual suspects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"process_block(&mut lock, block, &provider, &processor, &mut db, &prices).await?\n")),(0,i.kt)("h3",{id:"srcpricesrs"},(0,i.kt)("inlineCode",{parentName:"h3"},"src/prices.rs")),(0,i.kt)("p",null,"First, generate the ABI with ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/ethers-contract/0.1.3/ethers_contract/macro.abigen.html"},"ethers::contract::abigen")," macro for the Uniswap contract, and store it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"abi/")," folder. This will help us decode binary data from the transactions that interact with this contract. There are many resources on this, but see ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.stackexchange.com/a/1171/34397"},"SO answer here"),"."),(0,i.kt)("h3",{id:"sample-inspector---srcinspectorsaavers"},"Sample inspector - ",(0,i.kt)("inlineCode",{parentName:"h3"},"src/inspectors/aave.rs")),(0,i.kt)("p",null,"This is the inspector for Aave."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/keyword.impl.html"},"As is customary in Rust"),", we define a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," for the data fields, and an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," for the methods on the object itself."),(0,i.kt)("p",null,"Aave inspector doesn't need a provider because it can simply load the ABI included in the repo."),(0,i.kt)("p",null,"Next we implment the Inspector interface for the Aave object, which is a function that takes in a mutable inspection object that we'll write fields to as a result of the inspection logic."),(0,i.kt)("h3",{id:"deriving-from-traits"},"Deriving from Traits"),(0,i.kt)("p",null,"It seems in rust that having structs derive from traits like ",(0,i.kt)("inlineCode",{parentName:"p"},"Debug")," is universally a good idea, but there are some others to be careful of. ",(0,i.kt)("a",{parentName:"p",href:"https://users.rust-lang.org/t/what-traits-should-i-normally-derive/484/9"},"Good post on the subject here"),"."))}h.isMDXComponent=!0}}]);