"use strict";(self.webpackChunkflashbot_docs=self.webpackChunkflashbot_docs||[]).push([[4347],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,E=p["".concat(l,".").concat(m)]||p[m]||u[m]||i;return n?a.createElement(E,o(o({ref:t},d),{},{components:n})):a.createElement(E,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5229:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={title:"websockets"},l=void 0,c={unversionedId:"flashbots-protect/api/websockets",id:"flashbots-protect/api/websockets",isDocsHomePage:!1,title:"websockets",description:"The WebSockets integration of the Flashbots Protect API is built for Web3 Javascript/Typescript frontends. Frontend clients can use the socket.io-client library to send transactions, cancel transactions, retrieve transaction status updates, and retrieve recommeneded fees (optional).",source:"@site/docs/flashbots-protect/api/websockets.md",sourceDirName:"flashbots-protect/api",slug:"/flashbots-protect/api/websockets",permalink:"/flashbots-protect/api/websockets",tags:[],version:"current",frontMatter:{title:"websockets"},sidebar:"docs",previous:{title:"json rpc",permalink:"/flashbots-protect/api/json-rpc"},next:{title:"signing transactions",permalink:"/flashbots-protect/api/signing-transactions"}},d=[{value:"Endpoints",id:"endpoints",children:[]},{value:"Installation",id:"installation",children:[]},{value:"Events",id:"events",children:[]},{value:"Implementation",id:"implementation",children:[{value:"Interfaces and Enums",id:"interfaces-and-enums",children:[]},{value:"Initializing The Client",id:"initializing-the-client",children:[]},{value:"Socket Session",id:"socket-session",children:[]},{value:"Sending &amp; Receiving Bundle Events",id:"sending--receiving-bundle-events",children:[]},{value:"Recommended fees (optional)",id:"recommended-fees-optional",children:[]},{value:"Errors",id:"errors",children:[]}]}],u={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The WebSockets integration of the Flashbots Protect API is built for Web3 Javascript/Typescript frontends. Frontend clients can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"socket.io-client")," library to send transactions, cancel transactions, retrieve transaction status updates, and retrieve recommeneded fees (optional)."),(0,i.kt)("p",null,"As a part of this guide we assume you are familiar with WebSockets and the Socket.io client API. To learn more about implementing a WebSockets client with Socket.io, checkout this link ",(0,i.kt)("a",{parentName:"p",href:"https://socket.io/docs/v4/client-api/"},"Socket.io Client API Docs")),(0,i.kt)("p",null,"Alternatively, the mistX team at Alchemist has provided an easy to use WebSockets SDK that interfaces with the Flashbots Protect API. ",(0,i.kt)("a",{parentName:"p",href:"https://docs.mistx.io/docs/mistx/ZG9jOjIyNDQ2MDk-websockets-sdk"},"Learn more about the WebSockets SDK by mistX")),(0,i.kt)("h2",{id:"endpoints"},"Endpoints"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Staging"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Current version: v1.8.0"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"https://protection-staging.flashbots.net"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Production"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Current version: v1.8.0"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"https://protection.flashbots.net"))),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"npm i --save socket.io-client\n")),(0,i.kt)("h2",{id:"events"},"Events"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Example"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BUNDLE_REQUEST"),(0,i.kt)("td",{parentName:"tr",align:null},"Publish"),(0,i.kt)("td",{parentName:"tr",align:null},"Submit a bundle of transactions"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.emit(Event.BUNDLE_REQUEST, ...)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BUNDLE_STATUS_REQUEST"),(0,i.kt)("td",{parentName:"tr",align:null},"Publish"),(0,i.kt)("td",{parentName:"tr",align:null},"Manually request the last status of a bundle"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.emit(Event.BUNDLE_STATUS_REQUEST, ...)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BUNDLE_CANCEL_REQUEST"),(0,i.kt)("td",{parentName:"tr",align:null},"Publish"),(0,i.kt)("td",{parentName:"tr",align:null},"Cancel a bundle"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.emit(Event.BUNDLE_CANCEL_REQUEST, ...)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BUNDLE_RESPONSE"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe to bundle status changes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.on(Event.BUNDLE_RESPONSE, ...)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SOCKET_SESSION"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe"),(0,i.kt)("td",{parentName:"tr",align:null},"Retrive the token for the socket session"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.on(Event.SOCKET_SESSION, ...)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"FEES_CHANGE"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe to the recommended fees for the latest block"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.on(Event.FEES_CHANGE, ...)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SOCKET_ERR"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe to errors"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"socket.on(Event.SOCKET_ERR, ...)"))))),(0,i.kt)("h2",{id:"implementation"},"Implementation"),(0,i.kt)("h3",{id:"interfaces-and-enums"},"Interfaces and Enums"),(0,i.kt)("p",null,"The Interfaces and Enums used throughout this documentation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"\n// Event names sent and received by the client\nexport enum Event {\n\n  // Sent by the WebSocket client.\n  BUNDLE_REQUEST = 'BUNDLE_REQUEST',\n  BUNDLE_STATUS_REQUEST = 'BUNDLE_STATUS_REQUEST',\n  BUNDLE_CANCEL_REQUEST = 'BUNDLE_CANCEL_REQUEST',\n\n  // Received by the WebSocket client.\n  FEES_CHANGE = 'FEES_CHANGE',\n  SOCKET_SESSION = 'SOCKET_SESSION',\n  SOCKET_ERR = 'SOCKET_ERR',\n  BUNDLE_RESPONSE = 'BUNDLE_RESPONSE'\n\n}\n\n// Used to derive the Status of a Transaction\nexport enum Status {\n  PENDING_BUNDLE = 'PENDING_BUNDLE',\n  FAILED_BUNDLE = 'FAILED_BUNDLE',\n  SUCCESSFUL_BUNDLE = 'SUCCESSFUL_BUNDLE',\n  CANCEL_BUNDLE_SUCCESSFUL = 'CANCEL_BUNDLE_SUCCESSFUL',\n  BUNDLE_NOT_FOUND = 'BUNDLE_NOT_FOUND'\n}\n\n// Maps events to callbacks with argument types\nexport interface QuoteEventsMap {\n  [Event.FEES_CHANGE]: (response: Fees) => void\n  [Event.SOCKET_SESSION]: (response: SocketSession) => void\n  [Event.SOCKET_ERR]: (err: any) => void\n  [Event.BUNDLE_RESPONSE]: (response: BundleRes) => void\n  [Event.BUNDLE_REQUEST]: (response: any) => void\n  [Event.BUNDLE_CANCEL_REQUEST]: (serialized: any) => void\n  [Event.BUNDLE_STATUS_REQUEST]: (serialized: any) => void\n}\n\n// Session payload, used to provide a token for session affinity.\nexport interface SocketSession {\n  token: string\n}\n\n// Transaction bundle request payload.\nexport interface BundleReq {\n  transactions: string[]  // Array[String], A list of signed transactions\n}\n\n// Transaction bundle response payload.\nexport interface BundleRes {\n  bundle: {\n    id: string;             // NOTE: this is the Flashbots Protect bundle id\n    transactions: string[]; // Array[String], A list of signed transactions\n  };\n  status: Status;\n  message: string;\n  error: string;\n}\n\n// Fees payload received by the client\nexport interface Fee {\n  maxFeePerGas: BigNumberish\n  maxPriorityFeePerGas: BigNumberish\n}\nexport interface Fees {\n  block: number\n  baseFeePerGas: BigNumberish\n  default: Fee\n  low: Fee\n  med: Fee\n  high: Fee\n}\n\n// Error payload\nexport interface SocketErr {\n  event: Event;\n  message: string;\n  data?: any;\n}\n\n")),(0,i.kt)("h3",{id:"initializing-the-client"},"Initializing The Client"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"\nimport { io, Socket } from 'socket.io-client'\n\nconst defaultServerUrl = 'https://protection.flashbots.net'\nconst tokenKey = `SESSION_TOKEN`\n\n// Auth token for maintaining session affinity\n// On the first session this will be undefined\n//\n// the session token will be passed back in the SOCKET_SESSION\n// and should be saved in localStorage for use in subsequent sessions\nconst token = localStorage.getItem(tokenKey)\n\nconst socket = Socket<QuoteEventsMap, QuoteEventsMap> = io(defaultServerUrl, {\n  transports: ['websocket'], // important to only use ['websocket'] as the transports\n  auth: { token },\n  reconnection: true,\n  reconnectionDelay: 5000,\n  autoConnect: true\n})\n\n")),(0,i.kt)("h3",{id:"socket-session"},"Socket Session"),(0,i.kt)("p",null,"After initializing the client, the first event received will be ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.SOCKET_SESSION")," which returns a token. Store the token in local storage and use as the ",(0,i.kt)("inlineCode",{parentName:"p"},"auth.token")," in subseqent client initializations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"socket.on(Event.SOCKET_SESSION, (session: SocketSession) => {\n  localStorage.setItem(tokenKey, session.token)\n})\n\n")),(0,i.kt)("h3",{id:"sending--receiving-bundle-events"},"Sending & Receiving Bundle Events"),(0,i.kt)("p",null,"There are three types of bundle events sent by the client, ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_REQUEST"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_STATUS_REQUEST"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_CANCEL_REQUEST"),". Only one type of bundle event is received by the client, ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_RESPONSE"),". These events allow the client and Flashbots Protect API to communicate over the lifecycle of a bundle."),(0,i.kt)("h4",{id:"sending-a-bundle"},"Sending a bundle"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_REQUEST")," is used to send a bundle of transactions to the Flashbots Protect API. The transactions array contained in the ",(0,i.kt)("inlineCode",{parentName:"p"},"BundleReq")," is a list of raw signed transactions. ",(0,i.kt)("a",{parentName:"p",href:"/flashbots-protect/api/signing-transactions"},"Learn more about signing transactions")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'\nconst bundle: BundleReq = {\n  transactions: ["0x123abc..."]\n}\nfunction emitBundleRequest(bundle: BundleReq) {\n  socket.emit(Event.BUNDLE_REQUEST, bundle)\n}\n')),(0,i.kt)("h4",{id:"receiving-a-bundle-response"},"Receiving a bundle response"),(0,i.kt)("p",null,"Once a bundle has been sent by the client, the socket should listen for ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_RESPONSE")," to receive the id of the bundle and updates when the bundle status changes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"\nsocket.on(Event.BUNDLE_RESPONSE, (response: BundleRes) => {\n  console.log('Bundle Response')\n  // The response contains a bundle id that can be used to cancel a bundle or request a status update\n  console.log('Bundle ID: ', response.bundle.id)\n  console.log('Bundle Status: ', response.status)\n})\n")),(0,i.kt)("h4",{id:"cancelling-a-bundle"},"Cancelling a bundle"),(0,i.kt)("p",null,"The bundle id can be used to cancel a bundle using ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_CANCEL_REQUEST"),". The Flashbots Protect API will attempt to cancel the bundle before it is included on-chain by a miner. Cancellation is not guaranteed as the cancellation event may be received after a miner has already included the bundle."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const id = '0x222...f23f' // id retrieved from Event.BUNDLE_RESPONSE\nfunction emitBundleCancellation(id: string) {\n  socket.emit(Event.BUNDLE_CANCEL_REQUEST, { id })\n}\n")),(0,i.kt)("h4",{id:"manually-request-a-bundle-status"},"Manually request a bundle status"),(0,i.kt)("p",null,"While a bundle response is provided when the status of a bundle changes, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_STATUS_REQUEST")," can be used to manually trigger a ",(0,i.kt)("inlineCode",{parentName:"p"},"Event.BUNDLE_RESPONSE")," to retrieve the last status of a bundle. The main usecase of this event is to provide a way of retrieving the status of a bundle which may have changed while the client was disconnected."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const id = '0x222...f23f' // id retrieved from Event.BUNDLE_RESPONSE\nfunction emitStatusRequest(id: string) {\n  socket.emit(Event.BUNDLE_STATUS_REQUEST, { id })\n}\n")),(0,i.kt)("h3",{id:"recommended-fees-optional"},"Recommended fees (optional)"),(0,i.kt)("p",null,"To build a successful transaction, it is important to include enough fees to cover both the Ethereum ",(0,i.kt)("strong",{parentName:"p"},"baseFee")," as well as the ",(0,i.kt)("strong",{parentName:"p"},"miner tip")," (incentive for a miner to include your transaction in a block). It may be complex to estimate what the fees should be, especially when the network is heavily used and more transactions are competing with each other."),(0,i.kt)("p",null,"To help properly estimate miner fees, the Flashbots Protect API can optionally provide you ",(0,i.kt)("strong",{parentName:"p"},"recommended fees"),". These have been adjusted to ensure a good chance of inclusion while avoiding overpayment. The method ",(0,i.kt)("strong",{parentName:"p"},"eth_gasFees")," will return fees organized in three tiers, and you can choose which to surface to your users depending on their use case."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"low"),": lowest chance of inclusion. It will take more time to get included. Higher risk of not covering the baseFee in times of heavy traffic."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"medium"),": good chance of inclusion. It will be faster to get included. Medium risk of not covering the baseFee in times of heavy traffic."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"high"),": highest chance of inclusion and fastest time to inclusion. Lowest risk of not covering the baseFee in times of heavy traffic.")),(0,i.kt)("h4",{id:"receiving-fees"},"Receiving fees"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"socket.on(Event.FEES_CHANGE, (response: Fees) => {\n  console.log('Recommended Fees: ', response)\n})\n")),(0,i.kt)("h3",{id:"errors"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Event.SOCKET_ERR")," is used to listen to error events on the client. The ",(0,i.kt)("inlineCode",{parentName:"p"},"SocketErr")," contains an event name for which the error occured as well as a message describing the error. The ",(0,i.kt)("inlineCode",{parentName:"p"},"SocketErr")," may also contain ",(0,i.kt)("inlineCode",{parentName:"p"},"SocketErr.data")," which includes additional data pertaining to the event such as a bundle id."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"socket.on(Event.SOCKET_ERR, (err: SocketErr) => {\n  console.log('Error with socket event:', err.event)\n  console.log('Error message: ', err.message)\n  console.log('Error data: ', err.data)\n})\n")))}p.isMDXComponent=!0}}]);